/*******************整型和字符串之间变化******************************************************************/
// 无符号整型转字符串
void Int2Str(u8* str, u32 intnum)    
{
    u32 i, Div = 1000000000, j = 0, Status = 0;
   //32位无符号数最大是10位整数,所以Div=10 0000 0000
    for (i = 0; i < 10; i++)
    {
        str[j++] = (intnum / Div) + '0';//取最高位 转化成字符 
 
        intnum = intnum % Div;//去掉最高位
        Div /= 10;//还剩下10-i位要转换
        if ((str[j-1] == '0') && (Status == 0))//忽略最高位的'0'
        {
            j = 0;
        }
        else
        {
            Status++;
        }
    }
}

/**
 ****************************************************************
 * @brief int2str
 *
 * 功能：将整形(int)数据转换成字符串
 *
 * @param: n = 要转换的整形数据
 * @param: str = 存放字符串的首地址
 * @param: length = 转换后字符串的长度
 *
 ****************************************************************/
void int2str(int n, char *str,unsigned char *length)
{
    char buf[6] = "";
    int i = 0;
    int len = 0;
    // temp为n的绝对值
    int temp = n<0?-n:n;
    // 如果str为空，直接返回
    if(str == NULL)
    {
     return ;
    }
    //把tmp的每一位的数存入buf
    // 逆序存入，如1234 -> 在buf中为4321
		//memset(CHAR,0,5);
    while(temp)
    {
     buf[i++] = (temp%10) + '0';
     temp = temp / 10;
    }
    //如果是负数多留一位放符串
    len = n<0?++i:i;
		*length = len; 
    str[i] = 0;
    //反转字符串4321- 转成 -1234
    while(1)
    {
     i--;
     if(buf[len-i-1] == 0)
     {
        break;
     }
     str[i] = buf[len-i-1];
    }
    // 如果是符号，加回去
    if(i==0)
    {
        str[i] = '-';//添加负号
    }
}


/********************************字符串转整型**************************************************************/

int str2int1( char* str)
{
    int temp = 0;
    const char* p = str;
    if(str == NULL) return 0;
    if(*str == '-' || *str == '+')
    {
        str ++;
    }
    while( *str != 0)
    {
        if( *str < '0' || *str > '9')
        {
            break;
        }
        temp = temp*10 +(*str -'0');
        str ++;
    }
    if(*p == '-')
    {
        temp = -temp;
    }
    return temp;
}

/**********************************滑动窗口***************************************************/
//常用在字符串和数组的处理上 ，寻找最小长度最大长度之类

//一个字符串，要在里面找出最长且没有重复字符的子串，就像拿着卷尺在上面不停地缩拉测量

//子串就是这个卷尺的伸出部分，即一个窗口，左边缩进，右边拉出

//因为不能有重复的字符，在右端逐渐拉长的过程中，每新增加的一个新字符都要拿来和左侧子串中的字符做对比

//给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。


int lengthOfLongestSubstring(char * s){
	int i = 0, j = 0;															//i为左窗口   ，j为右窗口； 
	int maxlen = 0;
	int curlen = 0;
	int len = strlen(s);
	if (len == 0)
		return 0;                                                               //字符串长度为 0时返回 0；
	for (; j < len && len - i > maxlen; j++){
		curlen++;
		for (int k = i; k <= j; k++){
			if (s[k] == s[j + 1]){                                       //当发现 右窗口出现重复，左窗口向右移动到左侧发生重复的字符的右侧
				if (curlen > maxlen) 
					maxlen = curlen;
				i = k + 1;
				curlen = j - i + 1;
				break;
			 }
		}	
	}

	if (curlen > maxlen);
		return curlen;
	else
		return maxlen;
}

////*********************************************中心扩散法**************************************************************************/

//中心扩散法的思路是：遍历每一个索引，以这个索引为中心，利用“回文串”中心对称的特点，往两边扩散，看最多能扩散多远。

//题目  给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000*//// 



/*枚举“中心位置”时间复杂度为 O(N)，从“中心位置”扩散得到“回文子串”的时间复杂度为 O(N)，因此时间复杂度可以降到O(N2）
 在这里要注意一个细节：回文串在长度为奇数和偶数的时候，“回文中心”的形式是不一样的。
 奇数回文串的“中心”是一个具体的字符，例如：回文串 “aba” 的中心是字符 “a”；
 偶数回文串的“中心”是位于中间的两个字符的“空隙”，例如：回文串串 “abba” 的中心是两个 “b” 中间的那个“空隙”。*/







char * longestPalindrome(char * s){
    if(strlen(s)==0||strlen(s)==1)
		return s;
	int i,start,left,right,count,len;
	start = len =0;
	for(i=0;s[i]!='\0';i+=count){
		count = 1;
		left=i-1;
		right = i+1;
		while(s[right]!='\0'&&s[i]==s[right]){ //处理重复字符串
			right++;
			count++;
		}
		while(left>=0 && s[right]!='\0' && s[left] == s[right]){
			left--;
			right++;
	    }
        if(right-left-1>len){
		start = left+1;											
		len = right-left-1;
		}
						
	}	
	s[start + len] = '\0';      // 原地修改返回
	return s + start;
}


/******************************逆波兰表达式************************************************/

把中缀表达式转化为后缀表达式    

使用波兰计算法：
     先把数据入栈，当下一个数据为符号时，把前两个入栈的数据弹出，做对应计算后在把所得结果入栈，最后的结果就是需要的数值；




/******************把中缀表达式转化为后缀表达式*********************/

  规则 ：  
	从左到右遍历中缀表达式的每个数字和字符，若是数字则直接输出，
	若是符号，则判断其与栈顶符号的优先级，若是优先级低于栈顶符号将栈顶元素输出，直到栈空在入栈。
	若是左括号直接入栈，
	若是右括号，直到遇到左括号，将栈顶符号输出。
	最后记得把栈清空


/***********************使用递归的思想字符串逆序****************************************************/

void print{                  
	char a;
	scanf("%c",&a);
	if(a != '#')
		print();    //此时开始递归，递归的执行顺序 就是从返回的函数一点一点向前推进，正好和字符串缓存里的顺序相反可以反序输出
	if(a != '#')
		printf("%c",a);
}


/*递归思想的有序数列折半查找*/

int binary_search(int arr[], int left, int right,int ele){
    int mid = (left + right) / 2;  //边界条件是找到当前值，或者查找范围为空。否则每一次查找都将范围缩小一半。
　　 if(left>right){
　　　　　return -1;　　
     }
　　else{
		if (arr[mid] > ele)
			right = mid - 1;
		else if (arr[mid] < ele)
			left = mid + 1;
			else
				return mid;
    return binary_search(arr, left, right, ele);
	}
}



/******************************************KMP算法************************************************/

   KMP解决的是用线性复杂度在主串中查找第一次出现模式串的下标。
   
   KMP算法的NEXT数组的标法 ：在失配的字符前面，寻找前缀和后缀的共有长度，数组里面的数为 此长度加一
   对于第一个元素，下标都为0，第二个元素为 1;
   "前缀"指除了最后一个字符以外，一个字符串的全部头部组合；"后缀"指除了第一个字符以外，一个字符串的全部尾部组合。
   



